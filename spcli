#!/bin/bash
function init () {
  spcli_version="0.03"

  priv_mode="admin"
  system_console_log=/opt/spcli/log/system_console
  touch $system_console_log

  # enable history
  set -o history
  HISTFILE=/dev/null # will maintain our own history file
  spcli_history=/opt/spcli/log/history # will keep our own history here
  touch $spcli_history

  # find the virsh domain of the storage controller
  systemdisk="$(find /dev | grep _DataONTAPv.raw | grep -v mapper | grep -v by-id)"
  diskfilename=$(basename "$systemdisk")
  if [ ${#diskfilename} -gt 15 ];then
    domain=${diskfilename::${#diskfilename}-15}
  fi

  if [ "$domain" == "" ];then 
    echo "WARNING: No Controller Detected"
    echo
  fi 

  # detect unconfigured host
  if [ "$(which virsh)" == "" ];then host_setup_all;fi
  if [ "$(which ovs-vsctl)" == "" ];then host_setup_all;fi


  # start logging the system console
  if is_power_on; then log_system_console;fi

  # cache location for env file
  env=/opt/spcli/log/env

}

function confirm_dirty_shutdown () {
  while true; do
    read -r -p "This will cause a dirty shutdown of your appliance. Continue? [y/n] " choice
    case "$choice" in
      y|Y ) return 0 ;;
      n|N ) return 1 ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done
}

function confirm_sp_reboot () {
  while true; do
    read -r -p "The Service Processor will be rebooted.  Continue? [y/n] " choice
        case "$choice" in
      y|Y ) return 0 ;;
      n|N ) return 1 ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done
}

function extractenv () {
  offset="$(fdisk -l $systemdisk | grep FAT32 | tr -s ' ' | cut -d' ' -f2)s" 2>/dev/null
  if [ "$offset" != "" ];then  
    mcopy -n -i $systemdisk@@$offset ::env/env $env
  fi
}

function get_host_mgmt_network () {
  #get the first interface with a valid ipv4 address
  mgmt_port=$(ip -4 -o address | grep -v 192.168.122.1 | grep -v 127.0.0.1 |head -n 1|tr -s ' '|cut -d' ' -f2)
  if [ "$(ifconfig $mgmt_port | grep UP)" != "" ]; then mgmt_port_status="Up"; else mgmt_port_status="Down";fi
  mgmt_ip=$(ifconfig "$mgmt_port" | grep -v inet6 | grep inet | tr -s ' '| cut -d' ' -f3)
  mgmt_netmask=$(ifconfig "$mgmt_port" | grep -v inet6 | grep inet | tr -s ' '| cut -d' ' -f5)  
  mgmt_gateway=$(ip route | grep default | head -n 1 | cut -d' ' -f 3)
  mgmt_dns1=$(nmcli dev show | grep DNS | head -n 1 | tr -s ' ' | cut -d' ' -f2)

}

function injectenv () {
  offset="$(fdisk -l $systemdisk | grep FAT32 | tr -s ' ' | cut -d' ' -f2)s"
  mcopy -o -i $systemdisk@@$offset $env ::env/env 
}

function printenv () {
  extractenv
  if [ "$1" == "" ];then
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' 
  else 
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' | grep "$1="
  fi 
}

function getenv () {
  extractenv
  if [ "$1" != "" ];then
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' | grep "$1=" | cut -d= -f2
  fi 
}

function setenv () {
  if is_power_on; then
    echo "error: system power is on"
  else
    key=$(echo "$1=$2" | cut -d= -f1)
    val=$(echo "$1=$2" | cut -d= -f2)
    
    if  [ "$(getenv $key)" == "" ];then 
      sed -i "1asetenv $key \"$val\"" $env
    else
      sed -i "s~^\(setenv $key \).*~\1\"$val\"~" $env
    fi
    
    # remove checksum
    sed -i -e '/^[0-9]/d' $env

    injectenv
    #echo $(printenv $key)
  fi
}

function unsetenv () {
  if is_power_on; then
    echo "error: system power is on"
  else
    #get key
    key=$(echo "$1=" | cut -d= -f1)

    # remove key
    if [ "$key" != "" ];then
      sed -i "s/^\(setenv $key \).*//" $env
    fi 

    # remove checksum
    sed -i -e '/^[0-9]/d' $env

    injectenv
  fi
}

function is_power_on () {
  if [ "$(virsh --connect qemu:///system domstate $domain 2>/dev/null)" == "running" ]; then return 0; fi
  return 1
}

function events_info () {
    echo "Number of records: $(journalctl | wc -l)"
    echo "Oldest record's timestamp: $(journalctl | head -n 1 | cut -d' ' -f1-3)"
    echo "Latest record's timestamp: $(journalctl | tail -n 1 | cut -d' ' -f1-3)"
    echo
}

function events_newest () {
    count=$(echo "$cmd" | cut -d' ' -f 3)

    case $count in
        "" ) usage ;;
        0 | *[!0-9]*) echo "Argument is not an integer > 0 and should be"; usage ;;
        *) journalctl -n $count --no-pager
    esac
}

function events_oldest () {
    count=$(echo "$cmd" | cut -d' ' -f 3)

    case $count in
        "" ) usage ;;
        0 | *[!0-9]*) echo "Argument is not an integer > 0 and should be"; usage ;;
        *) journalctl | head -n $count 
    esac
}

function events_search () {
    searchstr=$(echo "$cmd" | cut -d' ' -f 3-)

    case $searchstr in
        "" ) usage ;;
        *) journalctl -g "$searchstr"
    esac
}

function log_system_console () {

  #trim noise from log
  sed -i '/spawn virsh/d' $system_console_log 
  sed -i '/Connected to domain/d' $system_console_log 
  sed -i '/Escape character is/d' $system_console_log 
  sed -i '/stream had I\/O failure/d' $system_console_log 

  # use expect so we can background this process
  expect -c "set timeout -1; spawn virsh --connect qemu:///system console $domain --force; expect eof" >> $system_console_log &
  disown

}

function host_setup_all () {
  if ! got_root;then 
    spcli host setup
  else
    echo 
    host_setup_packages
    host_storage_setup  
    host_network_setup
  fi
}

# Ensure the script is run with root privileges
function got_root (){
  if [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root."
    return 1
  fi
  return 0
}

# Function to convert netmask to CIDR prefix length
function netmask_to_cidr() {
  local netmask="$1"
  local cidr_prefix=0

  # Split the netmask into octets
  IFS='.' read -r -a octets <<< "$netmask"

  # Iterate through each octet
  for octet in "${octets[@]}"; do
      # Convert the octet to its binary representation
      local binary_octet=$(printf "%08d" "$(echo "obase=2; $octet" | bc)")

      # Count the number of '1's in the binary octet
      local ones_in_octet=$(echo "$binary_octet" | grep -o '1' | wc -l)
      cidr_prefix=$((cidr_prefix + ones_in_octet))
  done

  echo "$cidr_prefix"
}

function is_valid_ip () {
  echo "$1" | grep -qE "\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"
}

function is_valid_netmask () {
  echo "$1" | grep -qP '^(255\.){3}(255|254|252|248|240|224|192|128|0)$|^(255\.){2}(255|254|252|248|240|224|192|128|0)\.0$|^(255\.)(255|254|252|248|240|224|192|128|0)(\.0){2}$|^(255|254|252|248|240|224|192|128|0)(\.0){3}$'
}

function validate_bond_ports () {
  for word in $1; do
    if ! echo "$2" | grep -qw "$word"; then
      return 1
      break
    fi
  done
  return 0
}

function get_physical_network_interfaces () {
  interface_list=""
  # Iterate through each network interface in /sys/class/net/
  for interface in /sys/class/net/*; do
      # Extract the interface name (e.g., eth0, enp0s3)
      ifname=$(basename "$interface")

      # Check if the 'device' subdirectory exists, which typically indicates a physical device
      if [ -d "$interface/device" ]; then
          # Exclude loopback interface (lo)
          if [ "$ifname" != "lo" ]; then
              # Further check for virtual functions (e.g., virtfn0) to exclude some virtual interfaces
              # This is a heuristic and might need adjustment based on specific virtual setups
              if ! ls "$interface/device/" | grep -q "virtfn"; then
                  interface_list="$ifname $interface_list"
              fi
          fi
      fi
  done
  echo "$interface_list"
}

function host_network_setup (){
  while true; do read -r -p "Configure Host Networking? (y/n): [ ] " choice
    case "$choice" in 
      y|Y ) break ;;
      n|N ) return 1; break ;;
    esac
  done

  get_host_mgmt_network
  eth_interface=$(ip link show | grep -E ': (eth|enp|eno|ens)' | head -n 1 | cut -d' ' -f2 | cut -d':' -f1)
  interface_list="$(get_physical_network_interfaces)"

  # bridge
  bridge=$(nmcli d | grep ovs-bridge | cut -d' ' -f1)
  if [ "$bridge" == "" ];then 
    read -p "OVS Bridge: [br0] " bridge
            bridge=${bridge:-"br0"}
  else 
    echo  "OVS Bridge: $bridge"
  fi
  
  # bond
  bond=$(ovs-appctl bond/list | grep -v recircID | head -n1 | cut -f1)
  if [ "$bond" == "" ];then 
      default_bond="bond0"
      read -p "OVS Bond: [$default_bond] " bond
              bond=${bond:-"$default_bond"}
  else 
      echo "OVS Bond: $bond"
  fi 

  # bond mode
  echo
  echo "Available bonding modes: active-backup, balance-slb, balance-tcp, lacp"
  default_bond_mode=$(ovs-appctl bond/list | grep -v recircID | head -n1 | cut -f2)
  default_bond_mode=${default_bond_mode:-active-backup}
  while true; do 
    read -p "Enter the desired bonding mode: [$default_bond_mode] " bond_mode
    bond_mode=${bond_mode:-"$default_bond_mode"}
    case $bond_mode in 
      active-backup ) break ;;
      balance-slb   ) break ;;
      balance-tcp   ) break ;;
      lacp          ) break ;;
    esac
  done 

  # MTU
  while true; do 
    read -p "bond MTU: [9000] " bond_mtu
             bond_mtu=${bond_mtu:-9000}
    if [ "$bond_mtu" -le 9000 ] && [ "$bond_mtu" -ge 1500 ];then break;fi 
  done 

  # Interfaces
  echo
  echo    "Available Interfaces: $interface_list"

  # Mgmt Interface
  while true; do
    read -p "Mgmt Interface: [$eth_interface] " ip_interface
             ip_interface=${ip_interface:-"$eth_interface"}
    if echo "$interface_list $bridge" | grep -qw "$ip_interface"; then break; fi 
  done 

  # Bond interfaces
  while true; do
    default_bond_interfaces="${interface_list#$ip_interface}"
    if [[ -z "${default_bond_interfaces//[[:space:]]/}" ]];then default_bond_interfaces="$ip_interface";fi
    read -p "Bond Interfaces, separated by spaces: [ $default_bond_interfaces ] " bond_interfaces
           bond_interfaces=${bond_interfaces:-"$default_bond_interfaces"}
    if validate_bond_ports "$bond_interfaces" "$interface_list";then break; fi
  done

  # if mgmt interface is added to bond, move mgmt to the bridge
  if echo "$bond_interfaces" | grep -qw "$ip_interface"; then ip_interface="$bridge";fi

  # IP configuration
  while true; do
    read -p "IPv4 address: [$mgmt_ip] " ip_address
             ip_address=${ip_address:-"$mgmt_ip"}
    if is_valid_ip "$ip_address";then break; fi
  done

  while true; do
    read -p "IPv4 netmask: [$mgmt_netmask] " ip_netmask
             ip_netmask=${ip_netmask:-"$mgmt_netmask"}
    if is_valid_netmask "$ip_netmask";then 
      ip_cidr=$(netmask_to_cidr "$ip_netmask")
      break
    fi    
  done

  while true; do
    read -p "IPv4 gateway: [$mgmt_gateway] " ip_gateway
             ip_gateway=${ip_gateway:-"$mgmt_gateway"}
    if is_valid_ip "$ip_gateway";then break; fi
  done

  while true; do 
    read -p "IPv4 DNS Server: [$mgmt_dns1] " ip_dns1
             ip_dns1=${ip_dns1:-"$mgmt_dns1"}
    if is_valid_ip "$ip_dns1";then break; fi
  done
  
  echo
  echo "New Configuration:"
  echo "-------------------------------"
  echo "OVS Bridge:      $bridge"
  echo "OVS Bond:        $bond"
  echo "Bond Mode:       $bond_mode"
  echo "Bond Interfaces: $bond_interfaces"
  echo "Mgmt Interface:  $ip_interface"
  echo "IPv4 Address:    $ip_address"
  echo "IPv4 Netmask:    $ip_netmask"
  echo "IPv4 CIDR:       $ip_cidr"
  echo "IPv4 Gateway:    $ip_gateway"
  echo "IPv4 DNS:        $ip_dns1"
  echo

  while true; do read -r -p "Apply configuration? [y/n] " choice
    case "$choice" in 
      y|Y ) 
            #ensure running state is current
            systemctl restart NetworkManager 

            # create the ovs bridge
            echo "Creating bridge $bridge"
            if [ "$(nmcli conn show | grep ^$bridge)" == "" ];then 
              nmcli conn add type ovs-bridge conn.interface "$bridge" con-name "$bridge" autoconnect yes ipv6.addr-gen-mode 0 
            fi
            echo "bridge: $bridge"

            # create interface bridge interface
            echo "Creating bridge port"
            bridge_port=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep "$bridge:ovs-port" | cut -d: -f3)
            if [ "$bridge_port" == "" ];then 
              nmcli con add type ovs-port conn.interface "$bridge" master "$bridge" autoconnect yes
              bridge_port=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep "$bridge:ovs-port" | cut -d: -f3)
            fi 
            echo "bridge_port: $bridge_port"
            echo

            echo "Creating bridge interface"
            # tear down old bridge inteerface
            bridge_interface=$(nmcli -t -f TYPE,DEVICE,NAME c | grep "ovs-interface:$bridge" | cut -d: -f3)
            if [ "$bridge_interface" != "" ];then nmcli conn delete "$bridge_interface";fi 

            # create new bridge interface
            nmcli con add type ovs-interface slave-type ovs-port conn.interface "$bridge" master "$bridge_port" \
                  ipv4.method disabled mtu "$bond_mtu" ipv6.addr-gen-mode 0 autoconnect yes 
            
            # get bridge interface connection name
            bridge_interface=$(nmcli -t -f TYPE,DEVICE,NAME c | grep ovs-interface:br0 | cut -d: -f3)

            echo "bridge_interface: $bridge_interface"
            echo

            # tear down old interface
            conn_name=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep "$eth_interface:ethernet" | cut -d: -f3)
            if [ "$conn_name" != "" ];then nmcli conn delete "$conn_name";fi

            # tear down new interface
            conn_name=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep "$ip_interface:ethernet" | cut -d: -f3)
            if [ "$conn_name" != "" ];then nmcli conn delete "$conn_name";fi

            echo "Setting IP on $ip_interface"
            if [ "$ip_interface" == "$bridge" ];then 
              nmcli conn modify "$bridge_interface" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            
            else 
              nmcli conn add type ethernet conn.interface "$ip_interface" con-name "$ip_interface" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            fi

            # create the bond 
            echo "creating bond: $bond"
            if [ "$(nmcli conn show | grep ^$bond)" == "" ];then
              nmcli connection add type ovs-port conn.interface "$bond" master "$bridge" con-name "$bond"
            fi 

            echo "setting bond mode: $bond_mode"
            # set bond mode
            nmcli connection modify "$bond" ovs-port.bond-mode "$bond_mode"

            # set lacp mode
            if [ "$bond_mode" == "lacp" ];then 
              nmcli con modify "$bond" ovs-port.lacp active
            else 
              nmcli con modify "$bond" ovs-port.lacp off
            fi 

            echo "Adding interfaces to bond $bond: $bond_interfaces"
            # Add interfaces
            for eth in $bond_interfaces; do 
              # remove any existing connection
              conn_name=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep "$eth:ethernet" | cut -d: -f3)
              if [ "$conn_name" != "" ];then nmcli conn delete "$conn_name";fi

              # add interface to bond
              nmcli connection add type ethernet conn.interface "$eth" master "$bond" con-name "ovs-slave-$eth" mtu "$bond_mtu"
            done
            
            # Bring up the connections
            nmcli con up "$bridge"
            nmcli con up "$bond"
            for eth in $bond_interfaces; do 
              nmcli conn up "ovs-slave-$eth"
            done
            
            # apply changes
            systemctl restart NetworkManager

            break ;;
      n|N ) break ;;
      * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done

}

function host_network_show () {
  get_host_mgmt_network

  bridge=$(nmcli -t -f TYPE,DEVICE,CONNECTION d | grep ^ovs-bridge | cut -d: -f3)
  bond=$(nmcli -t -f TYPE,DEVICE,CONNECTION d | grep ^ovs-port | grep -v "$bridge" | cut -d: -f3)
  bond_mode=$(nmcli -t conn show "$bond" | grep bond-mode | cut -d: -f2)
  bond_interfaces=$(nmcli -t -f DEVICE,TYPE,CONNECTION d | grep ethernet | grep slave |cut -d: -f1 | tr '\n' ' ')

  echo
  echo "Network Configuration:"
  echo "-------------------------------"
  echo "OVS Bridge:      $bridge"
  echo "OVS Bond:        $bond"
  echo "Bond Mode:       $bond_mode"
  echo "Bond Interfaces: $bond_interfaces"
  echo "Mgmt Interface:  $mgmt_port"
  echo "IPv4 Address:    $mgmt_ip"
  echo "IPv4 Netmask:    $mgmt_netmask"
  echo "IPv4 Gateway:    $mgmt_gateway"
  echo "IPv4 DNS:        $mgmt_dns1"
  echo
}

function host_setup_packages () {
  # install packages
  while true; do
    read -r -p "Install kvm and required packages? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y qemu-kvm libvirt virt-install lshw lsscsi lsof telnet libibverbs fence-agents-all
          # Also listed as required in the docs but not really required
          #   pacemaker-2.1.4-5
          #   pcs-0.10.14-5
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  #install openvswitch from RDO
  while [[ "$(which ovs-vsctl)" == "" ]]; do
    read -r -p "Install openvswitch from RDO? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y http://trunk.rdoproject.org/rdo_release/rdo-release.el9s.rpm
          dnf install -y NetworkManager-ovs openvswitch
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  #install openvswitch from NVF
  while [[ "$(which ovs-vsctl)" == "" ]]; do
    read -r -p "Install openvswitch from NFV? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y centos-release-nfv-common centos-release-nfv-openvswitch
          dnf install -y NetworkManager-ovs openvswitch3.5
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  # Set qemu user and group
  sed -i 's/^#user =.*/user = "root"/' /etc/libvirt/qemu.conf
  sed -i 's/^#group =.*/group = "root"/' /etc/libvirt/qemu.conf

  # start and enable libvirtd
  systemctl enable libvirtd --now

  # configure udev rules
  echo 'SUBSYSTEM=="net", ACTION=="add", KERNEL=="ontapn*", ATTR{tx_queue_len}="5000"' > /etc/udev/rules.d/99-ontaptxqueuelen.rules

  # enable OpenVswitch
  if [[ "$(which ovs-vsctl)" != "" ]];then 
    systemctl enable openvswitch --now
  else 
    echo "WARNING: openvswitch is not installed."
  fi 

  # Restart NetworkManager
  systemctl restart NetworkManager

  # Enable root ssh 
  sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
  sed -i 's/PermitRootLogin no/PermitRootLogin yes/g' /etc/ssh/sshd_config

  # Restart the SSH service to apply changes
  systemctl restart sshd


}

function host_storage_setup () {
  # configure storage pool
  while true; do
    read -r -p "Configure Storage Pool? [y/n] " choice
    case "$choice" in
      y|Y )
          read -p "Storage pool name: [select_pool] " pool_name
          pool_name=${pool_name:-"select_pool"}
          echo 
          echo "Discovered block devices:"
          lsblk --list | grep -v lvm
          read -p "Storage pool block device: [$pool_device] " pool_device
          if [ "$pool_name" != "" ] && [ "$pool_device" != "" ];then 
            while true; do
              read -r -p "Storage pool [$pool_name] will be created on device [$pool_device]. Continue? [y/n] " choice
              case "$choice" in
                y|Y ) 
                      # Create the storage pool
                      if [ "$(virsh pool-list --name --all | grep $pool_name)" == "" ];then
                        virsh pool-define-as "$pool_name" logical --source-dev /dev/$pool_device --target=/dev/$pool_name
                      fi
                      if [ "$(virsh pool-list --name | grep $pool_name)" == "" ];then
                        virsh pool-build "$pool_name"
                        virsh pool-start "$pool_name"
                      fi
                      virsh pool-autostart "$pool_name"
                      if [ "$(virsh vol-list --pool select_pool | grep keepalive)" == "" ];then 
                        virsh vol-create-as --pool "$pool_name" --name keepalive --capacity 1g
                      fi
                      break ;;
                n|N ) break ;;
                  * ) echo "Invalid response: [ $choice ]." ;;
              esac
            done
            break
          else
            echo "Storage pool creation cancelled.  Pool: $pool_name, Device: $pool_device"
          fi
          ;;
        n|N ) break ;;
          * ) echo "Invalid response: [ $choice ]." ;;
      esac
    done

}

function host_storage_show () {
  echo "Storage Pools:"
  virsh pool-list --all --details
  echo 
  # List all storage pools (including inactive ones)
  pools=$(virsh pool-list --all --name)

  echo "Pools Backing Devices/Paths:"

  for pool_name in $pools; do
    # Dump the XML configuration for the pool
    xml_config=$(virsh pool-dumpxml "$pool_name")
    
    # Extract the pool type
    pool_type=$(echo "$xml_config" | xpath -q -e "/pool/@type" 2>/dev/null | cut -d\" -f2)

    # Extract the source device path or target path based on the pool type
    backing_device=""
    if [ "$pool_type" == "dir" ] || [ "$pool_type" == "fs" ] || [ "$pool_type" == "netfs" ]; then
        backing_device=$(echo "$xml_config" | xpath -q -e "/pool/target/path/text()" 2>/dev/null)
    elif [ "$pool_type" == "disk" ] || [ "$pool_type" == "iscsi" ] || [ "$pool_type" == "lvm" ] || [ "$pool_type" == "logical" ]; then
        backing_device=$(echo "$xml_config" | xpath -q -e "/pool/source/device/@path" 2>/dev/null | cut -d\" -f2)
    fi

    # Print the pool name and its backing device/path
    printf "Pool: %-20s Type: %-10s Backing Device/Path: %s\n" "$pool_name" "$pool_type" "$backing_device"
  done
  echo 
  echo "Storage Devices:"
  lsblk --list | grep -v lvm
}

# This just reloads the spcli script
# Does not reboot the host
function sp_reboot () {
  if confirm_sp_reboot; then 
    echo
    spcli && exit
  else 
    echo
  fi
}

function sp_status () {
   get_host_mgmt_network
   echo "SP CLI Version:       $spcli_version"
   echo "Firmware Version:     $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
   echo "Management port:      $mgmt_port"
   echo "Ethernet link:        $mgmt_port_status"
   echo "IPv4 configuration:"
   echo "  IP Address:         $mgmt_ip"
   echo "  Netmask:            $mgmt_netmask"
   echo "  Gateway:            $(ip route | grep default | cut -d' ' -f 3)"
}

function system_console () {
  if is_power_on; then
    virsh --connect qemu:///system -e ^D console "$domain" --force | tee -a $system_console_log
    log_system_console
  fi
}

function system_core () {
  if confirm_dirty_shutdown; then 
    virsh --connect qemu:///system inject-nmi "$domain"
  fi
  echo
}

function system_fru_list () {
  echo
  echo "  FRU ID      Name"
  echo "=============================================="
  echo "    0         Controller"
  echo "    1         Chassis"
  echo 
}

function system_fru_show () {
  fru_id=$(echo "$cmd" | cut -d' ' -f 4)
  case $fru_id in 
    0 )       system_fru_show_0 ;;
    1 )       system_fru_show_1 ;;
    *[0-9]* ) echo "Invalid fru id" ;;
    * )       usage ;;
  esac 

}

function system_fru_show_0 () {
  echo
  echo "'Controller' inventory data:"
  echo
  echo "*** Product Info Area ***"
  echo "Mfg name            NetApp, Inc."
  echo "Product Name        Select"
  echo "System Model        $(getenv SYS_MODEL)"
  echo "System Rev          $(getenv SYS_REV)"
  echo "System Serial       $(getenv SYS_SERIAL_NUM)"
  echo "System Id           $(getenv bootarg.nvram.sysid)"
  echo
  echo "*** Select Info Area ***"
  echo "CPU Cores:          $(virsh --connect qemu:///system vcpucount $domain | grep current | grep config | tr -s ' ' | cut -d' ' -f3)" 
  echo "Memory:            $(virsh --connect qemu:///system dominfo $domain | grep 'Max memory' | tr -s ' ' | cut -d':' -f2)"
  echo "System Disks:"
  echo "$(virsh --connect qemu:///system dumpxml $domain | grep 'source dev' | grep -v 'dev/disk/' | cut -d\' -f 2 | sed -e 's/^/                    /')"
  echo "Data Disks:"
  echo "$(virsh --connect qemu:///system dumpxml $domain | grep 'source dev' | grep 'dev/disk/' | cut -d\' -f 2 | sed -e 's/^/                    /')"
  echo 

}

function system_fru_show_1 () {
  echo 
  echo
  echo "'Chassis' inventory data:"
  echo
  dmidecode -t 3 -q
  dmidecode -t 2 -q
  dmidecode -t 1 -q
  echo
}

function system_log () {
  page_size=$( echo $cmd | awk -F'-p ' '{print $2}' | awk -F' ' '{print $1}')

  case $page_size in
    "" )
      system_log_filtered | 
        sed '/spawn virsh/d' | \
        sed '/Connected to domain/d' | \
        sed '/Escape character is/d' | \
        sed '/stream had I\/O failure/d'
      ;;
    *[0-9]*) 
      system_log_filtered | 
        sed '/spawn virsh/d' | \
        sed '/Connected to domain/d' | \
        sed '/Escape character is/d' | \
        sed '/stream had I\/O failure/d' | \
        more -d -n $page_size
      ;;
    * ) usage ;;
  esac
}

function system_log_filtered () {
  case $cmd in 
    "system log" ) cat $system_console_log ;;
    *"-a"*   ) system_log_all ;;
    *"-l 1"* ) system_log_1 ;;
    *"-l 2"* ) system_log_2 ;; 
    * ) usage ;;
  esac
}

# print both log 1 and log 2
function system_log_all () {
  system_log_1
  echo
  system_log_2
}

# system log 1 should contain the loader stage of the most recent boot
function system_log_1 () {
      echo "==================== Log #1 start"
      awk '/Loading kernel.../{f=1;s=""}f{s=s$0"\n"}END{printf "%s",s}' $system_console_log | awk '/---<<BOOT>>---/{exit} {print}'
      echo "==================== Log #1 end"
}

# system log 2 should contain everything after the loader stage of the most recent boot
function system_log_2 () {
  echo "==================== Log #2 start"
  if [ "$(grep '\-\-\-<<BOOT>>---' $system_console_log)" == "" ];then 
    cat $system_console_log;
  else
    awk '/---<<BOOT>>---/{f=1;s=""}f{s=s$0"\n"}END{printf "%s",s}' $system_console_log
  fi 
  echo "==================== Log #2 end"
}

function system_power_cycle () {
  if confirm_dirty_shutdown; then 
    if is_power_on; then 
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      virsh --connect qemu:///system start "$domain" > /dev/null
      log_system_console
      echo  
    fi
  fi
}

function system_power_halt () {
    virsh --connect qemu:///system shutdown "$domain"
}

function system_power_off () {
  if confirm_dirty_shutdown; then 
    if is_power_on; then
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      echo
    fi
  fi
}

function system_power_on () {
  if ! is_power_on; then
    virsh --connect qemu:///system start $domain > /dev/null
    log_system_console
  fi
}

function system_power_status () {
  if is_power_on; then
    echo "System Power is on"
  else
    echo "System Power is off"
  fi
}

function system_reset () {
  if confirm_dirty_shutdown; then 
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      virsh --connect qemu:///system start "$domain" > /dev/null
      log_system_console
      echo  
  fi
}

function system_reset_current () {
  booted_from="$(getenv BOOTED_FROM)"
  if [ "$booted_from" == "BACKUP" ];then 
    system_reset_backup
  else
    system_reset_primary 
  fi 
}

function system_reset_backup () {
  if confirm_dirty_shutdown; then
    virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
    virsh --connect qemu:///system start "$domain" > /dev/null
    echo
    sleep 1
    expect -c 'set timeout 1; \
               spawn virsh --connect qemu:///system console '$domain' --force; \
               expect "Booting in"; \
               send "boot_backup\r"; \
               send "boot_backup\r"; \
               sleep 2; \
               exit' >> $system_console_log
  fi
  log_system_console
}

function system_reset_primary () {
  if confirm_dirty_shutdown; then
    virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
    virsh --connect qemu:///system start "$domain" > /dev/null
    echo
    sleep 1
    expect -c 'set timeout 1; \
               spawn virsh --connect qemu:///system console '$domain' --force; \
               expect "Booting in"; \
               send "boot_primary\r"; \
               send "boot_primary\r"; \
               sleep 2; \
               exit' >> $system_console_log
  fi
  log_system_console
}

function usage () {
  case $cmd in 
    "date"*            ) echo "usage: date";;
    "events all"*      ) echo "usage: events all";;
    "events info"*     ) echo "usage: events info";;
    "events newest"*   ) echo "usage: events newest <number>" ;;
    "events oldest"*   ) echo "usage: events oldest <number>" ;;
    "events search"*   ) echo "usage: events search <string>" ;;
    "help"*            ) echo "usage: help [<command>]" ;;
    "system fru list"* ) echo "usage: system fru list" ;;
    "system fru show"* ) echo "usage: system fru show <FRU-ID>" ;;
    "system setenv"*   ) echo "usage: system setenv <key>=<value>" ;;
    "system unsetenv"* ) echo "usage: system unsetenv <key>" ;;
    "system log"*      ) echo "usage: system log [-a] [-p <page_size>] [-l <log_number>]" ;;
  esac
}

function help (){
  #trim help
  cmd=$(echo $cmd | sed "s/^help //")

  help_strings="
    date - print date and time
    events - print system events and event information
    events all - print all system events
    events info - print system event log information
    events newest - print newest system events
    events oldest - print oldest system events
    events search - search for and print system events
    exit - exit from the SP command line interface
    help - print command help
    priv - show and set user mode
    priv set admin - enter into admin user mode
    priv set -q admin - enter into admin user mode
    priv set advanced - enter into advanced user mode
    priv set -q advanced - enter into advanced user mode(quiet flag)
    priv set diag - enter into diag user mode
    priv set -q diag - enter into diag user mode(quiet flag)
    priv show - show current user mode
    priv set - set user mode
    sp - commands to control the SP
    sp reboot - reboot the SP
    sp status - print SP status information
    sp uptime - display the service processor uptime
    system - commands to control the system
    system acp - acp related commands
    system acp show - display ACP info status
    system acp sensors show - display expander sensors status
    system battery - battery related commands
    system battery show - display battery info status
    system console - connect to the system console
    system core - dump the system core and reset
    system fru - fru related commands
    system fru show - display fru id inventory data
    system fru list - list fru id
    system log - print system console logs
    system power - commands controlling system power
    system power cycle - power the system off, then on
    system power halt - halt the system
    system power off - power the system off
    system power on - power the system on
    system power status - print system power status
    system sensors - print system sensors
    system reset - reset the system using the selected firmware
    system reset backup - reset the system using the backup firmware
    system reset current - reset the system using the current firmware
    system reset primary - reset the system using the primary firmware
    system forensics - configure watchdog forensics collection settings
    system forensics show - show the system forensics configuration settings
    system forensics log - display or clear system forensics logs
    system watchdog - system watchdog commands
    system watchdog status - Display the system watchdog status
    version - print Service Processor version
    "
  
  if [ "$priv_mode" == "diag" ];then 
    help_strings="
      $help_strings
      host - configure host
      host network - host network related commands
      host network setup - configure host networking
      host network show - print host networking
      host setup - configure host
      host storage - host storage related commands
      host storage setup - configure host storage
      host storage show - print host storage
      system printenv - print system environment variables
      system setenv - print system environment variables
      system setenv - print system environment variables
    "
  fi

  case $cmd in 
    "help" | "?"  )
      # top level help
      echo "$help_strings" | awk '{$1=$1};1' | grep -E "^\b\w+ -" 
      echo 
      ;;
   * ) 
      # Parental match
      if [[ $(echo "$help_strings" | grep -E "\b$cmd \w+\b -" | wc -l) -gt 0 ]];then 
        echo "$help_strings" | awk '{$1=$1};1' | grep -E "\b$cmd \w+\b - "
        echo "$help_strings" | awk '{$1=$1};1' | grep -E "\b$cmd -q \w+\b - "
        echo
      else 
        # exact match
        echo "$help_strings" | awk '{$1=$1};1' | grep "^$cmd -"
      fi         
      ;;
  esac
}

function enforce_priv_mode () {
  case $cmd in
    *"system printenv"* ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
    *"system setenv"*   ) if [ "$priv_mode" != "diag" ]; then cmd="unathorized";fi ;;
    *"system unsetenv"* ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
    *"host setup"*      ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
    *"host network"*      ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
  esac 
}

function run_command () {
  # process command
  case $cmd in
    ""     ) ;;
    "date" ) date ;;
    "date "* ) usage ;;
    "events all" ) journalctl ;;
    "events all "* ) usage ;;
    "events info" ) events_info ;;
    "events info "* ) usage;;
    "events newest"* ) events_newest ;;
    "events oldest"* ) events_oldest ;;
    "events search"* ) events_search ;;
    "events" | "events "* ) help ;;
    "exit" | "exit "* ) exit ;;
    "help help" ) usage ;;
    "help" | "help "* | "?"  ) help ;;
    "host" ) help ;;
    "host setup" | "host setup all" ) host_setup_all ;;
    "host setup packages" ) host_setup_packages ;;
    "host network" ) help ;;
    "host network setup" | "host setup network" ) host_network_setup ;;
    "host network show" ) host_network_show ;;
    "host storage" ) help ;;
    "host storage setup" | "host setup storage" ) host_storage_setup ;;
    "host storage show" ) host_storage_show ;;
    "priv set" | "priv set admin" | "priv set admin "* )
        priv_mode="admin"
        echo "Administrative commands"
        echo ;;
    "priv set -q admin" | "priv set -q admin "* )
        priv_mode="admin"
        ;;
    "priv set advanced" | "priv set advanced "* )
        priv_mode="advanced"
        echo "Warning: These advanced commands are potentially dangerous; use them only when directed to do so by support personnel."
        echo ;;
    "priv set -q advanced" | "priv set -q advanced "* ) priv_mode="advanced" ;;
    "priv set diag" | "priv set diag "* )
        priv_mode="diag"
        echo "Warning: These diagnostic commands are for use by support personnel only."
        echo ;;
    "priv set -q diag" | "priv set -q diag "* ) priv_mode="diag" ;;
    "priv show" | "priv" | "priv show "* ) 
        echo "$priv_mode"
        echo ;;
    "priv set"* ) help ;;
    "sp reboot" ) sp_reboot ;;
    "sp status" ) sp_status ;;
    "sp uptime" ) uptime ;;
    "sp" | "sp "* ) help ;;
    "system acp show" ) echo "ACP is not available" ;;
    "system acp sensors show" ) echo "ACP is not available" ;;
    "system battery show" ) upower -i `upower -e | grep 'BAT'` ;;
    "system console" ) system_console ;;
    "system core" ) system_core ;;
    "system fru list" ) system_fru_list ;;
    "system fru list "* ) usage ;;
    "system fru show"* ) system_fru_show ;;
    "system log" | "system log "* ) system_log ;; # | more -d -n 10 
    "system power cycle" ) system_power_cycle ;;
    "system power halt" ) virsh --connect qemu:///system shutdown "$domain";;
    "system power off" ) system_power_off ;;
    "system power on" ) system_power_on ;;
    "system power status" ) system_power_status ;;
    "system printenv" | "system printenv "* ) printenv "$(echo $cmd | cut -d' ' -f3-)" ;;
    "system getenv" | "system getenv "* ) getenv "$(echo $cmd | cut -d' ' -f3-)" ;;
    "system setenv "* ) setenv "$(echo $cmd | cut -d' ' -f3)" "$(echo $cmd | cut -d' ' -f4)"; echo $cmd | cut -d' ' -f4 ;;
    "system setenv" ) usage ;;
    "system unsetenv "* ) unsetenv "$(echo $cmd | cut -d' ' -f3)" ;;
    "system unsetenv" ) usage ;;
    "system reset" ) system_reset ;;
    "system reset backup" ) system_reset_backup ;;
    "system reset current" ) system_reset_current ;;
    "system reset primary" ) system_reset_primary ;;
    "system sensors" ) sensors ;;
    "system forensics show" ) echo "Forensics enabled: false"; echo;;
    "system watchdog status" ) virsh --connect qemu:///system dumpxml "$domain" | grep watchdog ;;
    "system"* ) help ;;
    "version" ) echo "SP CLI for ONTAP Select version $spcli_version" ;;
    * ) echo "command not found. Type '?' for a list of available commands."
  esac
}

# main loop
function main () {
  init

  # if a command was passed as an argument, run it then exit.
  if [ "$*" != "" ]; then 
    cmd="$*"
    run_command
    exit
  fi

  # start an interactive shell
  while true; do

    # set prompt
    case $priv_mode in
      "admin" ) prompt="SP $domain>" ;;
      "advanced" ) prompt="SP $domain*>" ;;
      "diag" ) prompt="SP $domain*>" ;;
    esac

    # read command with custom history
    history -c
    history -r $spcli_history
    read -ep "$prompt " cmd
    if [ "$cmd" != "" ] && [ "$cmd" != "$(tail $spcli_history -n 1)" ];then echo "$cmd" >> $spcli_history;fi
    
    enforce_priv_mode
    run_command

  done

}

main $*
