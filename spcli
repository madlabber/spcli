#!/bin/bash
function init () {
  spcli_version="0.03"

  priv_mode="admin"
  system_console_log=/opt/spcli/log/system_console
  touch $system_console_log

  # enable history
  set -o history
  HISTFILE=/dev/null # will maintain our own history file
  spcli_history=/opt/spcli/log/history # will keep our own history here
  touch $spcli_history

  # find the virsh domain of the storage controller
  systemdisk="$(find /dev | grep _DataONTAPv.raw | grep -v mapper | grep -v by-id)"
  diskfilename=$(basename "$systemdisk")
  if [ ${#diskfilename} -gt 15 ];then
    domain=${diskfilename::${#diskfilename}-15}
  fi

  if [ "$domain" == "" ];then 
    echo "WARNING: No Controller Detected"
    echo
  fi 

  # detect unconfigured host
  if [ "$(which virsh)" == "" ];then host_setup;fi

  # start logging the system console
  if is_power_on; then log_system_console;fi

  # cache location for env file
  env=/opt/spcli/log/env

}

function confirm_dirty_shutdown () {
  while true; do
    read -r -p "This will cause a dirty shutdown of your appliance. Continue? [y/n] " choice
    case "$choice" in
      y|Y ) return 0 ;;
      n|N ) return 1 ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done
}

function confirm_sp_reboot () {
  while true; do
    read -r -p "The Service Processor will be rebooted.  Continue? [y/n] " choice
        case "$choice" in
      y|Y ) return 0 ;;
      n|N ) return 1 ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done
}

function extractenv () {
  offset="$(fdisk -l $systemdisk | grep FAT32 | tr -s ' ' | cut -d' ' -f2)s" 2>/dev/null
  if [ "$offset" != "" ];then  
    mcopy -n -i $systemdisk@@$offset ::env/env $env
  fi
}

function get_host_mgmt_network () {
  #get the first interface with a valid ipv4 address
  mgmt_port=$(ip -4 -o address | grep -v 192.168.122.1 | grep -v 127.0.0.1 |head -n 1|tr -s ' '|cut -d' ' -f2)
  if [ "$(ifconfig $mgmt_port | grep UP)" != "" ]; then mgmt_port_status="Up"; else mgmt_port_status="Down";fi
  mgmt_ip=$(ifconfig "$mgmt_port" | grep -v inet6 | grep inet | tr -s ' '| cut -d' ' -f3)
  mgmt_netmask=$(ifconfig "$mgmt_port" | grep -v inet6 | grep inet | tr -s ' '| cut -d' ' -f5)  
  mgmt_gateway=$(ip route | grep default | cut -d' ' -f 3)
  mgmt_dns1=$(nmcli dev show | grep DNS | head -n 1 | tr -s ' ' | cut -d' ' -f2)

}

function injectenv () {
  offset="$(fdisk -l $systemdisk | grep FAT32 | tr -s ' ' | cut -d' ' -f2)s"
  mcopy -o -i $systemdisk@@$offset $env ::env/env 
}

function printenv () {
  extractenv
  if [ "$1" == "" ];then
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' 
  else 
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' | grep "$1="
  fi 
}

function getenv () {
  extractenv
  if [ "$1" != "" ];then
    cat $env | grep setenv | sort | sed 's^setenv ^^' | sed 's^ ^=^' | sed 's^"^^g' | grep "$1=" | cut -d= -f2
  fi 
}

function setenv () {
  if is_power_on; then
    echo "error: system power is on"
  else
    key=$(echo "$1=$2" | cut -d= -f1)
    val=$(echo "$1=$2" | cut -d= -f2)
    
    if  [ "$(getenv $key)" == "" ];then 
      sed -i "1asetenv $key \"$val\"" $env
    else
      sed -i "s~^\(setenv $key \).*~\1\"$val\"~" $env
    fi
    
    # remove checksum
    sed -i -e '/^[0-9]/d' $env

    injectenv
    #echo $(printenv $key)
  fi
}

function unsetenv () {
  if is_power_on; then
    echo "error: system power is on"
  else
    #get key
    key=$(echo "$1=" | cut -d= -f1)

    # remove key
    if [ "$key" != "" ];then
      sed -i "s/^\(setenv $key \).*//" $env
    fi 

    # remove checksum
    sed -i -e '/^[0-9]/d' $env

    injectenv
  fi
}

function is_power_on () {
  if [ "$(virsh --connect qemu:///system domstate $domain 2>/dev/null)" == "running" ]; then return 0; fi
  return 1
}

function events_info () {
    echo "Number of records: $(journalctl | wc -l)"
    echo "Oldest record's timestamp: $(journalctl | head -n 1 | cut -d' ' -f1-3)"
    echo "Latest record's timestamp: $(journalctl | tail -n 1 | cut -d' ' -f1-3)"
    echo
}

function events_newest () {
    count=$(echo "$cmd" | cut -d' ' -f 3)

    case $count in
        "" ) usage ;;
        0 | *[!0-9]*) echo "Argument is not an integer > 0 and should be"; usage ;;
        *) journalctl -n $count --no-pager
    esac
}

function events_oldest () {
    count=$(echo "$cmd" | cut -d' ' -f 3)

    case $count in
        "" ) usage ;;
        0 | *[!0-9]*) echo "Argument is not an integer > 0 and should be"; usage ;;
        *) journalctl | head -n $count 
    esac
}

function events_search () {
    searchstr=$(echo "$cmd" | cut -d' ' -f 3-)

    case $searchstr in
        "" ) usage ;;
        *) journalctl -g "$searchstr"
    esac
}

function log_system_console () {

  #trim noise from log
  sed -i '/spawn virsh/d' $system_console_log 
  sed -i '/Connected to domain/d' $system_console_log 
  sed -i '/Escape character is/d' $system_console_log 
  sed -i '/stream had I\/O failure/d' $system_console_log 

  # use expect so we can background this process
  expect -c "set timeout -1; spawn virsh --connect qemu:///system console $domain --force; expect eof" >> $system_console_log &
  disown

}

function host_setup_all () {
  echo 
  host_setup_packages
  host_setup_storage  
  #host_setup_network_2
  host_setup_network

}

# Ensure the script is run with root privileges
function am_i_root (){
  if [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root."
    return 1
  fi
  return 0
}

# Menu driven OVS config
ovs_menu() {
    PS3='Please enter your choice: '
    options=("Create Bridge" "Add Port to Bridge" "Create Bond" "Add Internal Port" "Add VLAN-tagged Port" "Show OVS Config" "Delete Bridge" "Exit")
    select opt in "${options[@]}"; do
        case $opt in
            "Create Bridge")
                read -p "Enter a name for the new bridge: " bridge_name
                if [ -z "$bridge_name" ]; then
                    echo "Bridge name cannot be empty."
                else
                    ovs-vsctl --may-exist add-br "$bridge_name"
                    if [ $? -eq 0 ]; then
                        echo "Bridge '$bridge_name' created successfully."
                    else
                        echo "Failed to create bridge '$bridge_name'."
                    fi
                fi
                ;;
            "Add Port to Bridge")
                read -p "Enter the bridge name: " bridge_name
                read -p "Enter the interface name to add: " interface_name
                if [ -z "$bridge_name" ] || [ -z "$interface_name" ]; then
                    echo "Bridge and interface names cannot be empty."
                else
                    ovs-vsctl br-exists "$bridge_name"
                    if [ $? -eq 0 ]; then
                        ovs-vsctl --may-exist add-port "$bridge_name" "$interface_name"
                        if [ $? -eq 0 ]; then
                            echo "Interface '$interface_name' added to bridge '$bridge_name'."
                        else
                            echo "Failed to add port '$interface_name'."
                        fi
                    else
                        echo "Error: Bridge '$bridge_name' does not exist."
                    fi
                fi
                ;;
            "Create Bond")
                read -p "Enter the bridge name to add the bond to: " bridge_name
                read -p "Enter a name for the new bond (e.g., bond0): " bond_name
                read -p "Enter the interfaces to bond (space-separated, e.g., eth1 eth2): " interfaces
                if [ -z "$bridge_name" ] || [ -z "$bond_name" ] || [ -z "$interfaces" ]; then
                    echo "Bridge name, bond name, and interfaces cannot be empty."
                else
                    ovs-vsctl br-exists "$bridge_name"
                    if [ $? -eq 0 ]; then
                        echo "Available bonding modes: active-backup, balance-slb, balance-tcp"
                        read -p "Enter the desired bonding mode (default: active-backup): " bond_mode
                        bond_mode=${bond_mode:-active-backup}

                        read -p "Do you want to use LACP? (y/n, default: n): " use_lacp
                        use_lacp=${use_lacp:-n}
                        lacp_option=""
                        if [[ "$use_lacp" == "y" ]]; then
                            lacp_option="lacp=active"
                            echo "Note: The remote switch must also be configured for LACP."
                        fi

                        ovs-vsctl add-bond "$bridge_name" "$bond_name" $interfaces bond_mode="$bond_mode" $lacp_option
                        if [ $? -eq 0 ]; then
                            echo "Bond '$bond_name' created on bridge '$bridge_name' with interfaces $interfaces."
                        else
                            echo "Failed to create bond '$bond_name'."
                        fi
                    else
                        echo "Error: Bridge '$bridge_name' does not exist."
                    fi
                fi
                ;;
            "Add Internal Port")
                read -p "Enter the bridge name: " bridge_name
                read -p "Enter a name for the new internal port: " port_name
                if [ -z "$bridge_name" ] || [ -z "$port_name" ]; then
                    echo "Bridge and port names cannot be empty."
                else
                    ovs-vsctl br-exists "$bridge_name"
                    if [ $? -eq 0 ]; then
                        ovs-vsctl --may-exist add-port "$bridge_name" "$port_name" -- set Interface "$port_name" type=internal
                        if [ $? -eq 0 ]; then
                            echo "Internal port '$port_name' created and added to bridge '$bridge_name'."
                        else
                            echo "Failed to create internal port '$port_name'."
                        fi
                    else
                        echo "Error: Bridge '$bridge_name' does not exist."
                    fi
                fi
                ;;
            "Add VLAN-tagged Port")
                read -p "Enter the bridge name: " bridge_name
                read -p "Enter the interface name to add: " interface_name
                read -p "Enter the VLAN tag: " vlan_tag
                if [ -z "$bridge_name" ] || [ -z "$interface_name" ] || [ -z "$vlan_tag" ]; then
                    echo "Bridge name, interface name, and VLAN tag cannot be empty."
                else
                    ovs-vsctl br-exists "$bridge_name"
                    if [ $? -eq 0 ]; then
                        ovs-vsctl --may-exist add-port "$bridge_name" "$interface_name" tag="$vlan_tag"
                        if [ $? -eq 0 ]; then
                            echo "Interface '$interface_name' added to bridge '$bridge_name' with VLAN tag $vlan_tag."
                        else
                            echo "Failed to add VLAN-tagged port."
                        fi
                    else
                        echo "Error: Bridge '$bridge_name' does not exist."
                    fi
                fi
                ;;
            "Show OVS Config")
                echo "Current Open vSwitch configuration:"
                ovs-vsctl show
                ;;
            "Delete Bridge")
                echo "Available bridges:"
                ovs-vsctl list-br
                read -p "Enter the name of the bridge to delete: " bridge_name
                if [ -z "$bridge_name" ]; then
                    echo "Bridge name cannot be empty."
                else
                    ovs-vsctl br-exists "$bridge_name"
                    if [ $? -eq 0 ]; then
                        ovs-vsctl del-br "$bridge_name"
                        if [ $? -eq 0 ]; then
                            echo "Bridge '$bridge_name' deleted successfully."
                        else
                            echo "Failed to delete bridge '$bridge_name'."
                        fi
                    else
                        echo "Error: Bridge '$bridge_name' does not exist."
                    fi
                fi
                ;;
            "Exit")
                echo "Exiting script. Goodbye!"
                break
                ;;
            *) echo "Invalid option. Please try again." ;;
        esac
        echo # Print a newline for spacing
    done
}

# Function to convert netmask to CIDR prefix length
netmask_to_cidr() {
    local netmask="$1"
    local cidr_prefix=0

    # Split the netmask into octets
    IFS='.' read -r -a octets <<< "$netmask"

    # Iterate through each octet
    for octet in "${octets[@]}"; do
        # Convert the octet to its binary representation
        local binary_octet=$(printf "%08d" "$(echo "obase=2; $octet" | bc)")

        # Count the number of '1's in the binary octet
        local ones_in_octet=$(echo "$binary_octet" | grep -o '1' | wc -l)
        cidr_prefix=$((cidr_prefix + ones_in_octet))
    done

    echo "$cidr_prefix"
}

function get_physical_network_interfaces () {
  interface_list=""
  # Iterate through each network interface in /sys/class/net/
  for interface in /sys/class/net/*; do
      # Extract the interface name (e.g., eth0, enp0s3)
      ifname=$(basename "$interface")

      # Check if the 'device' subdirectory exists, which typically indicates a physical device
      if [ -d "$interface/device" ]; then
          # Exclude loopback interface (lo)
          if [ "$ifname" != "lo" ]; then
              # Further check for virtual functions (e.g., virtfn0) to exclude some virtual interfaces
              # This is a heuristic and might need adjustment based on specific virtual setups
              if ! ls "$interface/device/" | grep -q "virtfn"; then
                  interface_list="$ifname $interface_list"
              fi
          fi
      fi
  done
  echo "$interface_list"
}

function host_setup_network_shared (){
  get_host_mgmt_network
  eth_interface=$(ip link show | grep -E ': (eth|enp|eno|ens)' | head -n 1 | cut -d' ' -f2 | cut -d':' -f1)
  bridge=$(nmcli d | grep ovs-bridge | cut -d' ' -f1)
  if [ "$bridge" == "" ];then 
    read -p "OVS Bridge: [br0] " bridge
              bridge=${bridge:-"br0"}
  else 
    echo  "OVS Bridge: $bridge"
  fi
  echo    "OVS Port: $eth_interface"
  read -p "IPv4 address: [$mgmt_ip] " ip_address
            ip_address=${ip_address:-"$mgmt_ip"}
  read -p "IPv4 netmask: [$mgmt_netmask] " ip_netmask
            ip_netmask=${ip_netmask:-"$mgmt_netmask"}
  read -p "IPv4 gateway: [$mgmt_gateway] " ip_gateway
            ip_gateway=${ip_gateway:-"$mgmt_gateway"}
  read -p "IPv4 DNS Server: [$mgmt_dns1] " ip_dns1
            ip_dns1=${ip_dns1:-"$mgmt_dns1"}
  ip_cidr=$(netmask_to_cidr "$ip_netmask")
  echo
  echo "New Configuration:"
  echo "-------------------------------"
  echo "OVS Bridge:     $bridge"
  echo "OVS Port:       $eth_interface"
  echo "Mgmt Interface: $bridge"
  echo "IPv4 Address:   $ip_address"
  echo "IPv4 Netmask:   $ip_netmask"
  echo "IPv4 CIDR:      $ip_cidr"
  echo "IPv4 Gateway:   $ip_gateway"
  echo "IPv4 DNS:       $ip_dns1"
  echo
  while true; do read -r -p "Apply configuration? [y/n] " choice
    case "$choice" in 
      y|Y ) 
      # create ovs bridge
            #ensure running state is current
            systemctl restart NetworkManager 
            # delete the config for the shared interface
            if [ "$(nmcli conn show | grep ^$eth_interface)" != "" ];then nmcli conn delete "$eth_interface";fi 
            # create the ovs bridge
            if [ "$(nmcli conn show | grep ^$bridge)" == "" ];then 
              nmcli conn add type ovs-bridge conn.interface "$bridge" con-name "$bridge" autoconnect yes ipv6.addr-gen-mode 0 
            fi
            if [ "$(nmcli conn show | grep ^ovs-slave-$bridge | grep ovs-port)" == "" ];then 
              nmcli conn add type ovs-port conn.interface "$bridge" master "$bridge" autoconnect yes
            fi 
            ovs_interface=$(nmcli -t d | grep ^$bridge:ovs-interface |cut -d: -f4)
            if [ "$ovs_interface" == "" ];then
              nmcli conn add \
                type ovs-interface \
                slave-type ovs-port \
                conn.interface "$bridge" \
                master "$bridge" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            fi
            ovs_interface=$(nmcli -t d | grep ^$bridge:ovs-interface |cut -d: -f4)
            if [ "$ovs_interface" != "" ];then
              nmcli conn modify "$ovs_interface" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            fi
            if [ "$(nmcli conn show | grep ^ovs-slave-$eth_interface | grep ovs-port)" == "" ];then
              nmcli conn add type ovs-port conn.interface "$eth_interface" master "$bridge" autoconnect yes  
            fi 
            if [ "$(nmcli conn show | grep ^ovs-slave-$eth_interface | grep ethernet)" == "" ];then
              nmcli conn add type ethernet conn.interface "$eth_interface" master "$eth_interface" autoconnect yes 
            fi 
            # apply changes
            systemctl restart NetworkManager
            break ;;
      n|N ) break ;;
      * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done

}

function host_setup_network_2 (){
  get_host_mgmt_network
  eth_interface=$(ip link show | grep -E ': (eth|enp|eno|ens)' | head -n 1 | cut -d' ' -f2 | cut -d':' -f1)
  bridge=$(nmcli d | grep ovs-bridge | cut -d' ' -f1)
  if [ "$bridge" == "" ];then 
    read -p "OVS Bridge: [br0] " bridge
              bridge=${bridge:-"br0"}
  else 
    echo  "OVS Bridge: $bridge"
  fi

  # empty bond could indicate single uplink
  read -p "OVS Bond: [bond0] " bond
            bond=${bond:-"bond0"}
  echo "Enter the physical interface names to add to the bond, separated by spaces (e.g., $(get_physical_network_interfaces)):"
  read -p "Bond Interfaces: " INTERFACES

  # prompt for bond type

  # should prompt for mgmt interface
  # if it is in the bond list apply the config to the bridge
  echo    "Mgmt Interface: $eth_interface"

  read -p "IPv4 address: [$mgmt_ip] " ip_address
            ip_address=${ip_address:-"$mgmt_ip"}
  read -p "IPv4 netmask: [$mgmt_netmask] " ip_netmask
            ip_netmask=${ip_netmask:-"$mgmt_netmask"}
  read -p "IPv4 gateway: [$mgmt_gateway] " ip_gateway
            ip_gateway=${ip_gateway:-"$mgmt_gateway"}
  read -p "IPv4 DNS Server: [$mgmt_dns1] " ip_dns1
            ip_dns1=${ip_dns1:-"$mgmt_dns1"}
  ip_cidr=$(netmask_to_cidr "$ip_netmask")
  echo
  echo "New Configuration:"
  echo "-------------------------------"
  echo "OVS Bridge:     $bridge"
  echo "OVS Port:       $eth_interface"
  echo "Mgmt Interface: $bridge"
  echo "IPv4 Address:   $ip_address"
  echo "IPv4 Netmask:   $ip_netmask"
  echo "IPv4 CIDR:      $ip_cidr"
  echo "IPv4 Gateway:   $ip_gateway"
  echo "IPv4 DNS:       $ip_dns1"
  echo
  while false; do read -r -p "Apply configuration? [y/n] " choice
    case "$choice" in 
      y|Y ) 
      # create ovs bridge
            #ensure running state is current
            systemctl restart NetworkManager 
            # delete the config for the shared interface
            if [ "$(nmcli conn show | grep ^$eth_interface)" != "" ];then nmcli conn delete "$eth_interface";fi 
            # create the ovs bridge
            if [ "$(nmcli conn show | grep ^$bridge)" == "" ];then 
              nmcli conn add type ovs-bridge conn.interface "$bridge" con-name "$bridge" autoconnect yes ipv6.addr-gen-mode 0 
            fi
            if [ "$(nmcli conn show | grep ^ovs-slave-$bridge | grep ovs-port)" == "" ];then 
              nmcli conn add type ovs-port conn.interface "$bridge" master "$bridge" autoconnect yes
            fi 
            ovs_interface=$(nmcli -t d | grep ^$bridge:ovs-interface |cut -d: -f4)
            if [ "$ovs_interface" == "" ];then
              nmcli conn add \
                type ovs-interface \
                slave-type ovs-port \
                conn.interface "$bridge" \
                master "$bridge" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            fi
            ovs_interface=$(nmcli -t d | grep ^$bridge:ovs-interface |cut -d: -f4)
            if [ "$ovs_interface" != "" ];then
              nmcli conn modify "$ovs_interface" \
                ipv4.method manual \
                ipv4.address "$ip_address/$ip_cidr" \
                ipv4.gateway "$ip_gateway" \
                ipv4.dns "$ip_dns1" \
                autoconnect yes \
                ipv6.addr-gen-mode 0 
            fi
            if [ "$(nmcli conn show | grep ^ovs-slave-$eth_interface | grep ovs-port)" == "" ];then
              nmcli conn add type ovs-port conn.interface "$eth_interface" master "$bridge" autoconnect yes  
            fi 
            if [ "$(nmcli conn show | grep ^ovs-slave-$eth_interface | grep ethernet)" == "" ];then
              nmcli conn add type ethernet conn.interface "$eth_interface" master "$eth_interface" autoconnect yes 
            fi 
            # apply changes
            systemctl restart NetworkManager
            break ;;
      n|N ) break ;;
      * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done

}

function host_setup_network () { 
  while true; do read -r -p "Configure Host Networking? [y/n] " choice
    case "$choice" in 
      y|Y ) break ;;
      n|N ) return 1; break ;;
      * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done

  # detect single nic config here and branch to nmcli workflow
  nic_count=$(lspci | grep -i ethernet | wc -l)
  if [ "$nic_count" == "1" ];then 
    echo "Single NIC Configuration Detected."
    host_setup_network_shared
    return 0
  fi


  #otherwise go to ovs setup
  ovs_menu
  while true; do
    echo
    read -r -p "Configure OVS Bridge? [y/n] " choice
    case "$choice" in
      y|Y )
            read -p "Bridge name: [br0] " bridge
            bridge=${bridge:-"br0"}
            echo "bridge: $bridge"

            read -p "Uplink port name: " ovs_port
            echo "port: $ovs_port"          

            if ovs-vsctl br-exists "$bridge";then echo "bridge $bridge already exists.";fi 

            # test if uplink is shared
            # shared: run nmcli workflow
            # dedicated: run vsctl workflow

            # create ovs bridge
            # This version assumes a dedicated mgmt port
              # ovs-vsctl add-br br0
              # ovs-vsctl add-port br0 ens33
              # ovs-vsctl set int {{item}} mtu_request={{ovs_bond_mtu}}"
            break ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
  done

}

function host_setup_packages () {
  # install packages
  while true; do
    read -r -p "Install kvm and required packages? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y qemu-kvm libvirt virt-install lshw lsscsi lsof telnet libibverbs fence-agents-all
          # Also listed as required in the docs but not really required
          #   pacemaker-2.1.4-5
          #   pcs-0.10.14-5
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  #install openvswitch from RDO
  while [[ "$(which ovs-vsctl)" == "" ]]; do
    read -r -p "Install openvswitch from RDO? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y http://trunk.rdoproject.org/rdo_release/rdo-release.el9s.rpm
          dnf install -y NetworkManager-ovs openvswitch
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  #install openvswitch from NVF
  while [[ "$(which ovs-vsctl)" == "" ]]; do
    read -r -p "Install openvswitch from NFV? [y/n] " choice
    case "$choice" in
      y|Y )
          dnf install -y centos-release-nfv-common centos-release-nfv-openvswitch
          dnf install -y NetworkManager-ovs openvswitch3.5
          break
          ;;
      n|N ) break ;;
        * ) echo "Invalid response: [ $choice ]." ;;
    esac
    echo
  done

  # Set qemu user and group
  sed -i 's/^#user =.*/user = "root"/' /etc/libvirt/qemu.conf
  sed -i 's/^#group =.*/group = "root"/' /etc/libvirt/qemu.conf

  # start and enable libvirtd
  systemctl enable libvirtd --now

  # configure udev rules
  echo 'SUBSYSTEM=="net", ACTION=="add", KERNEL=="ontapn*", ATTR{tx_queue_len}="5000"' > /etc/udev/rules.d/99-ontaptxqueuelen.rules

  # enable OpenVswitch
  if [[ "$(which ovs-vsctl)" != "" ]];then 
    systemctl enable openvswitch --now
  else 
    echo "WARNING: openvswitch is not installed."
  fi 

  # Restart NetworkManager
  systemctl restart NetworkManager

}

function host_setup_storage () {
  # configure storage pool
  while true; do
    read -r -p "Configure Storage Pool? [y/n] " choice
    case "$choice" in
      y|Y )
          read -p "Storage pool name: [select_pool] " pool_name
          pool_name=${pool_name:-"select_pool"}
          echo 
          echo "Discovered block devices:"
          lsblk --list | grep -v lvm
          read -p "Storage pool block device: [$pool_device] " pool_device
          if [ "$pool_name" != "" ] && [ "$pool_device" != "" ];then 
            while true; do
              read -r -p "Storage pool [$pool_name] will be created on device [$pool_device]. Continue? [y/n] " choice
              case "$choice" in
                y|Y ) 
                      # Create the storage pool
                      if [ "$(virsh pool-list --name --all | grep $pool_name)" == "" ];then
                        virsh pool-define-as "$pool_name" logical --source-dev /dev/$pool_device --target=/dev/$pool_name
                      fi
                      if [ "$(virsh pool-list --name | grep $pool_name)" == "" ];then
                        virsh pool-build "$pool_name"
                        virsh pool-start "$pool_name"
                      fi
                      virsh pool-autostart "$pool_name"
                      if [ "$(virsh vol-list --pool select_pool | grep keepalive)" == "" ];then 
                        virsh vol-create-as --pool "$pool_name" --name keepalive --capacity 1g
                      fi
                      break ;;
                n|N ) break ;;
                  * ) echo "Invalid response: [ $choice ]." ;;
              esac
            done
            break
          else
            echo "Storage pool creation cancelled.  Pool: $pool_name, Device: $pool_device"
          fi
          ;;
        n|N ) break ;;
          * ) echo "Invalid response: [ $choice ]." ;;
      esac
    done

}

# This just reloads the spcli script
# Does not reboot the host
function sp_reboot () {
  if confirm_sp_reboot; then 
    echo
    spcli && exit
  else 
    echo
  fi
}

function sp_status () {
   get_host_mgmt_network
   echo "SP CLI Version:       $spcli_version"
   echo "Firmware Version:     $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
   echo "Management port:      $mgmt_port"
   echo "Ethernet link:        $mgmt_port_status"
   echo "IPv4 configuration:"
   echo "  IP Address:         $mgmt_ip"
   echo "  Netmask:            $mgmt_netmask"
   echo "  Gateway:            $(ip route | grep default | cut -d' ' -f 3)"
}

function system_console () {
  if is_power_on; then
    virsh --connect qemu:///system -e ^D console "$domain" --force | tee -a $system_console_log
    log_system_console
  fi
}

function system_core () {
  if confirm_dirty_shutdown; then 
    virsh --connect qemu:///system inject-nmi "$domain"
  fi
  echo
}

function system_fru_list () {
  echo
  echo "  FRU ID      Name"
  echo "=============================================="
  echo "    0         Controller"
  echo "    1         Chassis"
  echo 
}

function system_fru_show () {
  fru_id=$(echo "$cmd" | cut -d' ' -f 4)
  case $fru_id in 
    0 )       system_fru_show_0 ;;
    1 )       system_fru_show_1 ;;
    *[0-9]* ) echo "Invalid fru id" ;;
    * )       usage ;;
  esac 

}

function system_fru_show_0 () {
  echo
  echo "'Controller' inventory data:"
  echo
  echo "*** Product Info Area ***"
  echo "Mfg name            NetApp, Inc."
  echo "Product Name        Select"
  echo "System Model        $(getenv SYS_MODEL)"
  echo "System Rev          $(getenv SYS_REV)"
  echo "System Serial       $(getenv SYS_SERIAL_NUM)"
  echo "System Id           $(getenv bootarg.nvram.sysid)"
  echo
  echo "*** Select Info Area ***"
  echo "CPU Cores:          $(virsh --connect qemu:///system vcpucount $domain | grep current | grep config | tr -s ' ' | cut -d' ' -f3)" 
  echo "Memory:            $(virsh --connect qemu:///system dominfo $domain | grep 'Max memory' | tr -s ' ' | cut -d':' -f2)"
  echo "System Disks:"
  echo "$(virsh --connect qemu:///system dumpxml $domain | grep 'source dev' | grep -v 'dev/disk/' | cut -d\' -f 2 | sed -e 's/^/                    /')"
  echo "Data Disks:"
  echo "$(virsh --connect qemu:///system dumpxml $domain | grep 'source dev' | grep 'dev/disk/' | cut -d\' -f 2 | sed -e 's/^/                    /')"
  echo 

}

function system_fru_show_1 () {
  echo 
  echo
  echo "'Chassis' inventory data:"
  echo
  dmidecode -t 3 -q
  dmidecode -t 2 -q
  dmidecode -t 1 -q
  echo
}

function system_log () {
  page_size=$( echo $cmd | awk -F'-p ' '{print $2}' | awk -F' ' '{print $1}')

  case $page_size in
    "" )
      system_log_filtered | 
        sed '/spawn virsh/d' | \
        sed '/Connected to domain/d' | \
        sed '/Escape character is/d' | \
        sed '/stream had I\/O failure/d'
      ;;
    *[0-9]*) 
      system_log_filtered | 
        sed '/spawn virsh/d' | \
        sed '/Connected to domain/d' | \
        sed '/Escape character is/d' | \
        sed '/stream had I\/O failure/d' | \
        more -d -n $page_size
      ;;
    * ) usage ;;
  esac
}

function system_log_filtered () {
  case $cmd in 
    "system log" ) cat $system_console_log ;;
    *"-a"*   ) system_log_all ;;
    *"-l 1"* ) system_log_1 ;;
    *"-l 2"* ) system_log_2 ;; 
    * ) usage ;;
  esac
}

# print both log 1 and log 2
function system_log_all () {
  system_log_1
  echo
  system_log_2
}

# system log 1 should contain the loader stage of the most recent boot
function system_log_1 () {
      echo "==================== Log #1 start"
      awk '/Loading kernel.../{f=1;s=""}f{s=s$0"\n"}END{printf "%s",s}' $system_console_log | awk '/---<<BOOT>>---/{exit} {print}'
      echo "==================== Log #1 end"
}

# system log 2 should contain everything after the loader stage of the most recent boot
function system_log_2 () {
  echo "==================== Log #2 start"
  if [ "$(grep '\-\-\-<<BOOT>>---' $system_console_log)" == "" ];then 
    cat $system_console_log;
  else
    awk '/---<<BOOT>>---/{f=1;s=""}f{s=s$0"\n"}END{printf "%s",s}' $system_console_log
  fi 
  echo "==================== Log #2 end"
}

function system_power_cycle () {
  if confirm_dirty_shutdown; then 
    if is_power_on; then 
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      virsh --connect qemu:///system start "$domain" > /dev/null
      log_system_console
      echo  
    fi
  fi
}

function system_power_halt () {
    virsh --connect qemu:///system shutdown "$domain"
}

function system_power_off () {
  if confirm_dirty_shutdown; then 
    if is_power_on; then
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      echo
    fi
  fi
}

function system_power_on () {
  if ! is_power_on; then
    virsh --connect qemu:///system start $domain > /dev/null
    log_system_console
  fi
}

function system_power_status () {
  if is_power_on; then
    echo "System Power is on"
  else
    echo "System Power is off"
  fi
}

function system_reset () {
  if confirm_dirty_shutdown; then 
      virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
      virsh --connect qemu:///system start "$domain" > /dev/null
      log_system_console
      echo  
  fi
}

function system_reset_current () {
  booted_from="$(getenv BOOTED_FROM)"
  if [ "$booted_from" == "BACKUP" ];then 
    system_reset_backup
  else
    system_reset_primary 
  fi 
}

function system_reset_backup () {
  if confirm_dirty_shutdown; then
    virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
    virsh --connect qemu:///system start "$domain" > /dev/null
    echo
    sleep 1
    expect -c 'set timeout 1; \
               spawn virsh --connect qemu:///system console '$domain' --force; \
               expect "Booting in"; \
               send "boot_backup\r"; \
               send "boot_backup\r"; \
               sleep 2; \
               exit' >> $system_console_log
  fi
  log_system_console
}

function system_reset_primary () {
  if confirm_dirty_shutdown; then
    virsh --connect qemu:///system destroy "$domain" --graceful > /dev/null
    virsh --connect qemu:///system start "$domain" > /dev/null
    echo
    sleep 1
    expect -c 'set timeout 1; \
               spawn virsh --connect qemu:///system console '$domain' --force; \
               expect "Booting in"; \
               send "boot_primary\r"; \
               send "boot_primary\r"; \
               sleep 2; \
               exit' >> $system_console_log
  fi
  log_system_console
}

function usage () {
  case $cmd in 
    "date"*            ) echo "usage: date";;
    "events all"*      ) echo "usage: events all";;
    "events info"*     ) echo "usage: events info";;
    "events newest"*   ) echo "usage: events newest <number>" ;;
    "events oldest"*   ) echo "usage: events oldest <number>" ;;
    "events search"*   ) echo "usage: events search <string>" ;;
    "help"*            ) echo "usage: help [<command>]" ;;
    "system fru list"* ) echo "usage: system fru list" ;;
    "system fru show"* ) echo "usage: system fru show <FRU-ID>" ;;
    "system setenv"*   ) echo "usage: system setenv <key>=<value>" ;;
    "system unsetenv"* ) echo "usage: system unsetenv <key>" ;;
    "system log"*      ) echo "usage: system log [-a] [-p <page_size>] [-l <log_number>]" ;;
  esac
}

function help (){
  case $cmd in
    *"date"* )
        echo "date - print date and time" ;;
    *"events all"* ) 
        echo "events all - print all system events" ;;
    *"events info"* ) 
        echo "events info - print system event log information" ;;
    *"events newest"* )
        echo "events newest - print newest system events" ;;
    *"events oldest"* )
        echo "events oldest - print oldest system events" ;;
    *"events search"* )
        echo "events search - search for and print system events" ;;
    *"events"* )
        echo "events all - print all system events"
        echo "events info - print system event log information"
        echo "events newest - print newest system events"
        echo "events oldest - print oldest system events"
        echo "events search - search for and print system events"
        echo ;;
    *"exit"* )
        echo "exit - exit from the SP command line interface" ;;
    "help help"   )
        echo "help - print command help" ;;
    *"host"* )
        echo "host setup all - configure all host settings"
        echo "host setup network - configure host networking"
        echo "host setup packages - configure host software packages"
        echo "host setup storage - configure host storage"
        echo ;;
    *"priv set"* )
        echo "priv set admin - enter into admin user mode"
        echo "priv set -q admin - enter into admin user mode"
        echo "priv set advanced - enter into advanced user mode"
        echo "priv set -q advanced - enter into advanced user mode(quiet flag)"
        echo "priv set diag - enter into diag user mode"
        echo "priv set -q diag - enter into diag user mode(quiet flag)"
        echo ;;
    *"priv show"* )
        echo "priv show - show current user mode" ;;
    *"priv"* )
        echo "priv set - set user mode"
        echo "priv show - show current user mode"
        echo ;;
    *"sp reboot"* )
        echo "sp reboot - reboot the SP";;
    *"sp status"* )
        echo "sp status - print SP status information" ;;
    *"sp uptime" )
        echo "sp uptime - display the service processor uptime" ;;
    *"sp"* )
        echo "sp reboot - reboot the SP"
        echo "sp status - print SP status information"
        echo "sp uptime - display service processor uptime"
        echo ;;
    *"system acp show"* )
        echo "system acp show - display ACP info status" ;;
    *"system acp sensors show"* )
        echo "system acp sensors show - display expander sensors status" ;;
    *"system acp"* )
        echo "system acp show - display ACP info status"
        echo "system acp sensors show - display expander sensors status" 
        echo ;;
    *"system battery"* )
        echo "system battery show - display battery info status"
        echo ;;
    *"system console"* )
        echo "system console - connect to the system console" ;;
    *"system core"* )
        echo "system core - dump the system core and reset" ;;
    *"system fru"* )
        echo "system fru show - display fru id inventory data"
        echo "system fru list - list fru id" 
        echo ;;
    *"system log"* )
        echo "system log - print system console logs";;
    *"system printenv"* )
        echo "system printenv - print system environment variables" ;;
    *"system setenv"* )
        echo "system setenv - print system environment variables" ;;
    *"system unsetenv"* )
        echo "system setenv - print system environment variables" ;;
    *"system power"* )
        echo "system power cycle - power the system off, then on"
        echo "system power halt - halt the system"
        echo "system power off - power the system off"
        echo "system power on - power the system on"
        echo "system power status - print system power status"
        echo ;;
    *"system reset"* )
        echo "system reset backup - reset the system using the backup firmware"
        echo "system reset current - reset the system using the current firmware"
        echo "system reset primary - reset the system using the primary firmware"
        echo ;;
    *"system forensics"* )
        echo "system forensics show - show the system forensics configuration settins"
        echo "system forensics log - display or clear system forensics logs"
        echo ;;
    *"system watchdog"* )
        echo "system watchdog status - Display the system watchdog status"
        echo ;;
    *"system"* )
        echo "system acp - acp related commands"
        echo "system battery - battery related commands"
        echo "system console - connect to the system console"
        echo "system core - dump the system core and reset"
        echo "system log - print system console log"
        echo "system power - commands controlling system power"
        echo "system reset - reset the system using the selected firmware"
        echo "system sensors - print system sensors"
        echo "system fru - fru related commands"
        echo "system forensics - configure watchdog forensics collection settings"
        echo "system watchdog - system watchdog commands"
        # diag level commands
        if [ "$priv_mode" == "diag" ];then 
        echo "system printenv - print system environment variables"
        echo "system unsetenv - unset system environment variables"
        echo "system setenv - set system environment variables";fi 
        echo ;;
    *"version"* )
        echo "version - print Service Processor version" ;;
    *"help"* | "?"  )
        echo "date - print date and time"
        echo "exit - exit from the SP command line interface"
        echo "events - print system events and event information"
        echo "help - print command help"
        [ "$priv_mode" == "diag" ] && echo "host - configure host"
        echo "priv - show and set user mode"
        echo "sp - commands to control the SP"
        echo "system - commands to control the system"
        echo "version - print Service Processor version"
        echo ;;
    * ) usage ;;
  esac
}

function enforce_priv_mode () {
  case $cmd in
    *"system printenv"* ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
    *"system setenv"*   ) if [ "$priv_mode" != "diag" ]; then cmd="unathorized";fi ;;
    *"system unsetenv"* ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
    *"host setup"*      ) if [ "$priv_mode" != "diag" ]; then cmd="unauthorized";fi ;;
  esac 
}

function run_command () {
  # process command
  case $cmd in
    ""     ) ;;
    "date" ) date ;;
    "date "* ) usage ;;
    "events all" ) journalctl ;;
    "events all "* ) usage ;;
    "events info" ) events_info ;;
    "events info "* ) usage;;
    "events newest"* ) events_newest ;;
    "events oldest"* ) events_oldest ;;
    "events search"* ) events_search ;;
    "events" | "events "* ) help ;;
    "exit" | "exit "* ) exit ;;
    "help" | "help "* | "?"  ) help ;;
    "host" ) help ;;
    "host setup" | "host setup all" ) host_setup_all ;;
    "host setup packages" ) host_setup_packages ;;
    "host setup network" ) host_setup_network ;;
    "host setup storage" ) host_setup_storage ;;
    "priv set" | "priv set admin" | "priv set admin "* )
        priv_mode="admin"
        echo "Administrative commands"
        echo ;;
    "priv set -q admin" | "priv set -q admin "* )
        priv_mode="admin"
        ;;
    "priv set advanced" | "priv set advanced "* )
        priv_mode="advanced"
        echo "Warning: These advanced commands are potentially dangerous; use them only when directed to do so by support personnel."
        echo ;;
    "priv set -q advanced" | "priv set -q advanced "* ) priv_mode="advanced" ;;
    "priv set diag" | "priv set diag "* )
        priv_mode="diag"
        echo "Warning: These diagnostic commands are for use by support personnel only."
        echo ;;
    "priv set -q diag" | "priv set -q diag "* ) priv_mode="diag" ;;
    "priv show" | "priv" | "priv show "* ) 
        echo "$priv_mode"
        echo ;;
    "priv set"* ) help ;;
    "sp reboot" ) sp_reboot ;;
    "sp status" ) sp_status ;;
    "sp uptime" ) uptime ;;
    "sp" | "sp "* ) help ;;
    "system acp show" ) echo "ACP is not available" ;;
    "system acp sensors show" ) echo "ACP is not available" ;;
    "system battery show" ) upower -i `upower -e | grep 'BAT'` ;;
    "system console" ) system_console ;;
    "system core" ) system_core ;;
    "system fru list" ) system_fru_list ;;
    "system fru list "* ) usage ;;
    "system fru show"* ) system_fru_show ;;
    "system log" | "system log "* ) system_log ;; # | more -d -n 10 
    "system power cycle" ) system_power_cycle ;;
    "system power halt" ) virsh --connect qemu:///system shutdown "$domain";;
    "system power off" ) system_power_off ;;
    "system power on" ) system_power_on ;;
    "system power status" ) system_power_status ;;
    "system printenv" | "system printenv "* ) printenv "$(echo $cmd | cut -d' ' -f3-)" ;;
    "system getenv" | "system getenv "* ) getenv "$(echo $cmd | cut -d' ' -f3-)" ;;
    "system setenv "* ) setenv "$(echo $cmd | cut -d' ' -f3)" "$(echo $cmd | cut -d' ' -f4)"; echo $cmd | cut -d' ' -f4 ;;
    "system setenv" ) usage ;;
    "system unsetenv "* ) unsetenv "$(echo $cmd | cut -d' ' -f3)" ;;
    "system unsetenv" ) usage ;;
    "system reset" ) system_reset ;;
    "system reset backup" ) system_reset_backup ;;
    "system reset current" ) system_reset_current ;;
    "system reset primary" ) system_reset_primary ;;
    "system sensors" ) sensors ;;
    "system forensics show" ) echo "Forensics enabled: false"; echo;;
    "system watchdog status" ) virsh --connect qemu:///system dumpxml "$domain" | grep watchdog ;;
    "system"* ) help ;;
    "version" ) echo "SP CLI for ONTAP Select version $spcli_version" ;;
    * ) echo "command not found. Type '?' for a list of available commands."
  esac
}

# main loop
function main () {
  init

  # if a command was passed as an argument, run it then exit.
  if [ "$*" != "" ]; then 
    cmd="$*"
    run_command
    exit
  fi

  # start an interactive shell
  while true; do

    # set prompt
    case $priv_mode in
      "admin" ) prompt="SP $domain>" ;;
      "advanced" ) prompt="SP $domain*>" ;;
      "diag" ) prompt="SP $domain*>" ;;
    esac

    # read command with custom history
    history -c
    history -r $spcli_history
    read -ep "$prompt " cmd
    if [ "$cmd" != "" ] && [ "$cmd" != "$(tail $spcli_history -n 1)" ];then echo "$cmd" >> $spcli_history;fi
    
    enforce_priv_mode
    run_command

  done

}

main $*
